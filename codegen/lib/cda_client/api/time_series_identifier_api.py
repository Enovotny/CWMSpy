# coding: utf-8

"""
    CWMS Data API

    CWMS REST API for Data Retrieval  # noqa: E501

    OpenAPI spec version: 3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from cda_client.api_client import ApiClient


class TimeSeriesIdentifierApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(self, timeseries_id, office, method, **kwargs):  # noqa: E501
        """Delete cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        Deletes requested timeseries identifier  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(timeseries_id, office, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: The timeseries-id of the timeseries to be deleted.  (required)
        :param str office: Specifies the owning office of the timeseries to be deleted. (required)
        :param DeleteMethod method: Specifies the delete method used. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, method, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, method, **kwargs)  # noqa: E501
            return data

    def delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(self, timeseries_id, office, method, **kwargs):  # noqa: E501
        """Delete cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        Deletes requested timeseries identifier  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: The timeseries-id of the timeseries to be deleted.  (required)
        :param str office: Specifies the owning office of the timeseries to be deleted. (required)
        :param DeleteMethod method: Specifies the delete method used. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timeseries_id', 'office', 'method']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timeseries_id' is set
        if ('timeseries_id' not in params or
                params['timeseries_id'] is None):
            raise ValueError("Missing the required parameter `timeseries_id` when calling `delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501
        # verify the required parameter 'office' is set
        if ('office' not in params or
                params['office'] is None):
            raise ValueError("Missing the required parameter `office` when calling `delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `delete_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'timeseries_id' in params:
            path_params['timeseries-id'] = params['timeseries_id']  # noqa: E501

        query_params = []
        if 'office' in params:
            query_params.append(('office', params['office']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'CwmsAAACacAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cwms-data/timeseries/identifier-descriptor/{timeseries-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cwms_data_timeseries_identifier_descriptor(self, **kwargs):  # noqa: E501
        """Get cwmsData timeseries identifierDescriptor  # noqa: E501

        Returns CWMS timeseries identifier descriptorData  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cwms_data_timeseries_identifier_descriptor(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str office: Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
        :param str timeseries_id_regex: A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
        :param str page: This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the 'next-page' value in the response.
        :param int page_size: How many entries per page returned. Default 500.
        :return: TimeSeriesIdentifierDescriptors
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cwms_data_timeseries_identifier_descriptor_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cwms_data_timeseries_identifier_descriptor_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cwms_data_timeseries_identifier_descriptor_with_http_info(self, **kwargs):  # noqa: E501
        """Get cwmsData timeseries identifierDescriptor  # noqa: E501

        Returns CWMS timeseries identifier descriptorData  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cwms_data_timeseries_identifier_descriptor_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str office: Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
        :param str timeseries_id_regex: A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
        :param str page: This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the 'next-page' value in the response.
        :param int page_size: How many entries per page returned. Default 500.
        :return: TimeSeriesIdentifierDescriptors
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office', 'timeseries_id_regex', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cwms_data_timeseries_identifier_descriptor" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'office' in params:
            query_params.append(('office', params['office']))  # noqa: E501
        if 'timeseries_id_regex' in params:
            query_params.append(('timeseries-id-regex', params['timeseries_id_regex']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page-size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json;version=2'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cwms-data/timeseries/identifier-descriptor', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesIdentifierDescriptors',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(self, timeseries_id, office, **kwargs):  # noqa: E501
        """Get cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        Retrieves requested timeseries identifier descriptor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(timeseries_id, office, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: Specifies the identifier of the timeseries to be included in the response. (required)
        :param str office: Specifies the owning office of the timeseries identifier to be included in the response. (required)
        :return: TimeSeriesIdentifierDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, **kwargs)  # noqa: E501
            return data

    def get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(self, timeseries_id, office, **kwargs):  # noqa: E501
        """Get cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        Retrieves requested timeseries identifier descriptor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, office, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: Specifies the identifier of the timeseries to be included in the response. (required)
        :param str office: Specifies the owning office of the timeseries identifier to be included in the response. (required)
        :return: TimeSeriesIdentifierDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timeseries_id', 'office']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timeseries_id' is set
        if ('timeseries_id' not in params or
                params['timeseries_id'] is None):
            raise ValueError("Missing the required parameter `timeseries_id` when calling `get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501
        # verify the required parameter 'office' is set
        if ('office' not in params or
                params['office'] is None):
            raise ValueError("Missing the required parameter `office` when calling `get_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'timeseries_id' in params:
            path_params['timeseries-id'] = params['timeseries_id']  # noqa: E501

        query_params = []
        if 'office' in params:
            query_params.append(('office', params['office']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json;version=2'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cwms-data/timeseries/identifier-descriptor/{timeseries-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesIdentifierDescriptor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(self, timeseries_id, timeseries_id, office, **kwargs):  # noqa: E501
        """Patch cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id(timeseries_id, timeseries_id, office, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: (required)
        :param str timeseries_id: A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided (required)
        :param str office: Specifies the owning office of the timeseries identifier to be updated (required)
        :param int interval_offset: The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
        :param int snap_forward: The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
        :param int snap_backward: The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
        :param bool active: 'True' or 'true' if the time series is active
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, timeseries_id, office, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, timeseries_id, office, **kwargs)  # noqa: E501
            return data

    def patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(self, timeseries_id, timeseries_id, office, **kwargs):  # noqa: E501
        """Patch cwmsData timeseries identifierDescriptor with timeseriesId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id_with_http_info(timeseries_id, timeseries_id, office, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timeseries_id: (required)
        :param str timeseries_id: A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided (required)
        :param str office: Specifies the owning office of the timeseries identifier to be updated (required)
        :param int interval_offset: The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
        :param int snap_forward: The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
        :param int snap_backward: The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
        :param bool active: 'True' or 'true' if the time series is active
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timeseries_id', 'timeseries_id', 'office', 'interval_offset', 'snap_forward', 'snap_backward', 'active']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timeseries_id' is set
        if ('timeseries_id' not in params or
                params['timeseries_id'] is None):
            raise ValueError("Missing the required parameter `timeseries_id` when calling `patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501
        # verify the required parameter 'timeseries_id' is set
        if ('timeseries_id' not in params or
                params['timeseries_id'] is None):
            raise ValueError("Missing the required parameter `timeseries_id` when calling `patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501
        # verify the required parameter 'office' is set
        if ('office' not in params or
                params['office'] is None):
            raise ValueError("Missing the required parameter `office` when calling `patch_cwms_data_timeseries_identifier_descriptor_with_timeseries_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'timeseries_id' in params:
            path_params['timeseries-id'] = params['timeseries_id']  # noqa: E501

        query_params = []
        if 'timeseries_id' in params:
            query_params.append(('timeseries-id', params['timeseries_id']))  # noqa: E501
        if 'office' in params:
            query_params.append(('office', params['office']))  # noqa: E501
        if 'interval_offset' in params:
            query_params.append(('interval-offset', params['interval_offset']))  # noqa: E501
        if 'snap_forward' in params:
            query_params.append(('snap-forward', params['snap_forward']))  # noqa: E501
        if 'snap_backward' in params:
            query_params.append(('snap-backward', params['snap_backward']))  # noqa: E501
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'CwmsAAACacAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cwms-data/timeseries/identifier-descriptor/{timeseries-id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_cwms_data_timeseries_identifier_descriptor(self, body, **kwargs):  # noqa: E501
        """Post cwmsData timeseries identifierDescriptor  # noqa: E501

        Create new TimeSeriesIdentifierDescriptor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_cwms_data_timeseries_identifier_descriptor(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TimeSeriesIdentifierDescriptor body: (required)
        :param bool fail_if_exists: Create will fail if provided ID already exists. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_cwms_data_timeseries_identifier_descriptor_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_cwms_data_timeseries_identifier_descriptor_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_cwms_data_timeseries_identifier_descriptor_with_http_info(self, body, **kwargs):  # noqa: E501
        """Post cwmsData timeseries identifierDescriptor  # noqa: E501

        Create new TimeSeriesIdentifierDescriptor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_cwms_data_timeseries_identifier_descriptor_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TimeSeriesIdentifierDescriptor body: (required)
        :param bool fail_if_exists: Create will fail if provided ID already exists. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'fail_if_exists']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_cwms_data_timeseries_identifier_descriptor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_cwms_data_timeseries_identifier_descriptor`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fail_if_exists' in params:
            query_params.append(('fail-if-exists', params['fail_if_exists']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;version=2', 'application/xml;version=2'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'CwmsAAACacAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cwms-data/timeseries/identifier-descriptor', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
